<!doctype html>
<html>
  <head>
    <title>CesiumJS VR by IDMapping</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <div id="cesiumContainer"></div>
    <script>

        let container, gl, program, refSpace, xrSession, buttons, xrButton, renderGL, firstEye,
            eyeOffset = 0,
            vshader = '',
            fshader = '',
            start = () => {},
            end = () => {},
            draw = () => {},
            drawStart = () => {},
            drawEnd = () => {},
            init = () => {},
            runGamepad = () => {},
            onInputChange = () => {};

        function initXR(_container, _gl, _renderGL) {
            container = _container ? document.getElementById(_container) : createContainer();
            gl = _gl ? _gl : createGL();
            if(!gl) initXR(_container, _gl, _renderGL);
            init();
            if(!_gl) processGL();
            createXRBtn();
            createFullscreenBtn();
            renderGL = _renderGL ? _renderGL : () => {
                if(checkSession()) return cancelAnimationFrame(renderGL);
                requestAnimationFrame(renderGL);
                draw();
            };
            requestAnimationFrame(render);
            if(navigator.xr) navigator.xr.isSessionSupported('immersive-vr')
                .then(supported => xrButton.textContent = 'Enter VR', xrButton.disabled = false, xrButton.onclick = onClick)
                .catch(() => xrButton.textContent = 'Session not Supported');
            else xrButton.textContent = 'Browser not supported';
        }

        function createContainer() {
            const c = document.createElement('div');
            c.style.cssText = 'position:absolute;top:0;left:0;height:100%;width:100%;';
            document.body.appendChild(c);
            return c;
        }

        function createGL() {
            const canvas = document.createElement('canvas');
            canvas.innerHTML = 'canvas not available';
            canvas.setAttribute('style', 'height:100%;width:100%;display:block;');
            container.appendChild(canvas);
            canvas.addEventListener('webglcontextlost', e => e.preventDefault());
            canvas.addEventListener("webglcontextrestored", () => console.log('webglcontextrestored'));
            return canvas.getContext('webgl', {
                xrCompatible: true
            });
        }

        function processGL() {
            const shaderv = gl.createShader(gl.VERTEX_SHADER);
            if(!vshader) vshader = 'void main(){}';
            if(!fshader) fshader = 'void main(){}';
            gl.shaderSource(shaderv, vshader);
            gl.compileShader(shaderv);
            const shaderf = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(shaderf, fshader);
            gl.compileShader(shaderf);
            program = gl.createProgram();
            gl.attachShader(program, shaderv);
            gl.attachShader(program, shaderf);
            gl.linkProgram(program);
            gl.enable(gl.DEPTH_TEST);
            if(gl.getProgramParameter(program, gl.LINK_STATUS)) gl.useProgram(program);
            else console.log(gl.getProgramInfoLog(program));
            end = () => {
                const c = gl.canvas;
                if(c.width !== c.clientWidth || c.height !== c.clientHeight) c.width = container.clientWidth, c.height = container.clientHeight;
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, c.width, c.height);
            };
            new ResizeObserver(end).observe(document.body);
        }

        function createXRBtn() {
            buttons = document.createElement('div');
            buttons.style.cssText = 'position:absolute;bottom:0;right:0;padding:2px;';
            container.appendChild(buttons);
            xrButton = createButton('Loading...');
            xrButton.disabled = true;
        }

        function createFullscreenBtn() {
            let fstatus = false;
            createButton('Fullscreen').onclick = () => {
                if(fstatus && document.exitFullscreen) document.exitFullscreen();
                else if(container.requestFullscreen) container.requestFullscreen();
                fstatus = !fstatus;
            };
        }

        function createButton(txt) {
            const btn = document.createElement('button');
            btn.innerHTML = txt;
            btn.style.cssText = 'cursor:pointer;user-select:none;font-weight:bold;padding:6px 8px;margin:0;outline:none;border:1px solid #000;background:#fff;';
            btn.onmouseover = () => {
                btn.style.background = '#ddd';
            };
            btn.onmouseleave = () => {
                btn.style.background = '#fff';
            };
            buttons.appendChild(btn);
            return btn;
        }

        function checkSession() {
            let session = false;
            if(xrSession)
                if(xrSession.inputSources) session = true;
            return session;
        }

        function render() {
            requestAnimationFrame(render);
            renderGL();
        }

        function renderSession() {
            xrSession.requestAnimationFrame(renderSession);
            renderGL();
        }

        function onClick() {
            if(xrSession) {
                if(renderGL) xrSession.cancelAnimationFrame(renderSession);
                xrSession.end();
                if(renderGL) requestAnimationFrame(renderGL);
            } else {
                if(renderGL) cancelAnimationFrame(renderGL);
                navigator.xr.requestSession('immersive-vr').then(onStart);
            }
        }

        function onStart(session) {
            xrSession = session;
            xrButton.textContent = 'Exit VR';
            if(renderGL) session.requestAnimationFrame(renderSession);
            start();
            session.addEventListener('end', onEnd);
            session.addEventListener('selectstart', onSelectStart);
            session.addEventListener('selectend', onSelectEnd);
            session.addEventListener('select', onSelect);
            session.addEventListener('squeezestart', onSqueezeStart);
            session.addEventListener('squeezeend', onSqueezeEnd);
            session.addEventListener('squeeze', onSqueeze);
            session.addEventListener('inputsourceschange', onInputSourcesChange);
            session.addEventListener('visibilitychange', onVisibilityChange);
            session.updateRenderState({
                baseLayer: new XRWebGLLayer(session, gl)
            });
            session.requestReferenceSpace('local').then(ref => {
                refSpace = ref;
                session.requestAnimationFrame(onDraw);
            });
        }

        function onEnd() {
            if(renderGL) xrSession.cancelAnimationFrame(renderSession);
            xrSession = null;
            if(renderGL) requestAnimationFrame(renderGL);
            xrButton.textContent = 'Enter VR';
            end();
        }

        function onDraw(time, frame) {
            const session = frame.session,
                pose = frame.getViewerPose(refSpace);
            session.requestAnimationFrame(onDraw);
            drawStart(session, frame, refSpace);
            if(pose) {
                const glLayer = session.renderState.baseLayer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
                for(let view of pose.views) getFirstEye(pose, view, glLayer) & draw(view, glLayer);
                for(let source of session.inputSources)
                    if(source.gamepad) runGamepad(source.gamepad, source.handedness, frame.getPose(source.gripSpace, refSpace));
                drawEnd(frame, pose, glLayer);
            }
        }

        function getFirstEye(pose, view, glLayer) {
            if(!firstEye) {
                firstEye = view.eye;
                const getPos = (a) => {
                    return Math.abs(pose.views[0].transform.position[a] - pose.views[1].transform.position[a]);
                };
                const xy = Math.sqrt(getPos('x') * getPos('x') + getPos('y') * getPos('y'));
                eyeOffset = (glLayer.framebufferWidth / 2) * Math.sqrt(xy * xy + getPos('z') * getPos('z'));
            }
        }

        function onSelectStart(e) {
            const targetRayPose = e.frame.getPose(e.inputSource.targetRaySpace, refSpace);
            if(!targetRayPose) return;
            const point = targetRayPose.transform.inverse.position;
            const transform = new DOMMatrix('scale(2)');
            const transformedPoint = point.matrixTransform(transform);
            console.log(transformedPoint);
        }

        function onSelectEnd(e) {}

        function onSelect(e) {}

        function onSqueezeStart(e) {}

        function onSqueezeEnd(e) {}

        function onSqueeze(e) {}

        function onInputSourcesChange(e) {
            for(let inputSource of e.added)
                if(inputSource.targetRayMode == 'tracked-pointer') onInputChange(inputSource);
        }

        function onVisibilityChange(e) {
            if(event.session.visibilityState === 'visible-blurred') {} else if(event.session.visibilityState === 'visible') {}
        }

        start = () => {
            if(canvas.width > canvas.height) _element.style.width = _container.clientHeight + 'px';
            else _element.style.height = _container.clientWidth + 'px';
        }
        end = () => {
            _element.style.width = _element.style.height = '100%';
        }
        draw = (view, glLayer) => {
            const viewport = glLayer.getViewport(view);
            gl.viewport(viewport.x + (view.eye == 'left' ? eyeOffset : -eyeOffset), viewport.y, viewport.width, viewport.height);
            if(view.eye == firstEye) {
                const orientation = view.transform.orientation;
                const hprOrigin = Cesium.HeadingPitchRoll.fromQuaternion(new Cesium.Quaternion(orientation.x, orientation.y, orientation.z, orientation.w));
                const hpr = new Cesium.HeadingPitchRoll(hprOrigin.pitch, hprOrigin.roll, hprOrigin.heading);
                camera.setView({
                    destination: camera.position,
                    orientation: {
                        heading: hpr.roll,
                        pitch: hpr.pitch - Math.PI / 2,
                        roll: 2 * Math.PI
                    }
                });
                camera.lookRight(hpr.heading);
            }
            context.draw(context._drawCommand, context._passState);
        }

        Cesium.DrawCommand.prototype.execute = function(ctx, passState) {
            ctx._drawCommand = this, ctx._passState = passState;
            ctx.draw(this, passState);
        };
        Cesium.Context.prototype.clear = function(clearCommand, passState) {
            clearCommand = Cesium.defaultValue(clearCommand, Cesium.defaultClearCommand);
            passState = Cesium.defaultValue(passState, this._defaultPassState);
            let bitmask = 0;
            const c = clearCommand.color;
            const d = clearCommand.depth;
            const s = clearCommand.stencil;
            if(Cesium.defined(c)) {
                if(!Cesium.Color.equals(this._clearColor, c)) {
                    Cesium.Color.clone(c, this._clearColor);
                    gl.clearColor(c.red, c.green, c.blue, c.alpha);
                }
                bitmask |= gl.COLOR_BUFFER_BIT;
            }
            if(Cesium.defined(d)) {
                if(d !== this._clearDepth) {
                    this._clearDepth = d;
                    gl.clearDepth(d);
                }
                bitmask |= gl.DEPTH_BUFFER_BIT;
            }
            if(Cesium.defined(s)) {
                if(s !== this._clearStencil) {
                    this._clearStencil = s;
                    gl.clearStencil(s);
                }
                bitmask |= gl.STENCIL_BUFFER_BIT;
            }
            const rs = Cesium.defaultValue(clearCommand.renderState, this._defaultRenderState);
            const previousRenderState = this._currentRenderState;
            const previousPassState = this._currentPassState;
            this._currentRenderState = rs;
            this._currentPassState = passState;
            Cesium.RenderState.partialApply(gl, previousRenderState, rs, previousPassState, passState, true);
            const framebuffer = Cesium.defaultValue(clearCommand.framebuffer, passState.framebuffer);
            if(framebuffer !== this._currentFramebuffer) {
                this._currentFramebuffer = framebuffer;
                let buffers = Cesium.scratchBackBufferArray;
                if(Cesium.defined(framebuffer)) {
                    framebuffer._bind();
                    buffers = framebuffer._getActiveColorAttachments();
                } else if(!xrSession) gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                if(this.drawBuffers && buffers && !xrSession) this.glDrawBuffers(buffers);
            }
            if(!xrSession) gl.clear(bitmask);
            else if(bitmask != 17408) gl.clear(bitmask); // 256,1024,16384,17408
        };

        const widget = new Cesium.CesiumWidget('cesiumContainer', {
            contextOptions: {
                webgl: {
                    xrCompatible: true
                }
            }
        });

        const _container = widget.container;
        const _element = widget._element;
        const _scene = widget.scene;
        const canvas = _scene.canvas;
        const context = _scene.context;
        const camera = widget.camera;

        widget.useDefaultRenderLoop = false;

        initXR(
            'cesiumContainer',
            context._gl,
            () => {
                widget.resize(), widget.render();
            }
        );

    </script>
  </body>
</html>
